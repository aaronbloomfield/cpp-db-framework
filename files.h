//--------------------------------------------------------------------------------
// dbobject.h

const char *dbobject_h = R"DBOBJH(//
// This file generated by the C++ DB framework: https://github.com/aaronbloomfield/cpp-db-framework

#ifndef DB_DBOBJECT_H
#define DB_DBOBJECT_H

#include <iostream>
#include <vector>
#include <string>
#include <mysql/mysql.h>

using namespace std;

namespace db {

class dbobject {
public:
  dbobject();
  virtual ~dbobject();

  static bool connect(string host, string db, string user, string passwd);
  static bool connect(char* host, char* db, char* user, char* passwd);
  static void disconnect();

  static void setVerbose (bool which);
  static void setMySQLConnection(MYSQL *conn);
  static void saveAll(vector<dbobject*> vec, MYSQL *conn = NULL);
  static void executeUpdate(string query, MYSQL *conn = NULL);
  static unsigned int getLastInsertID(MYSQL *conn = NULL);
  static MYSQL *getMySQLConnection();
  static void raise_error(string s);

  virtual void save(MYSQL *conn = NULL) = 0;
  virtual string getTableName() = 0;
  virtual unsigned int size_in_bytes() = 0;

  static void enable_reconnects (string host, string name, string user, string pass, int num);
  static void set_reconnect_callback ( void (*f)(int) );

  static unsigned long get_query_count();

protected:
  static bool _verbose;
  static MYSQL *theconn;

  virtual dbobject* readInFullRow(MYSQL_ROW row) = 0;
  virtual ostream& put(ostream &out) = 0;
  virtual bool isUpdate() = 0;

  static bool reconnect();
  static int num_reconnects_allowed();
  static void possibly_call_reconnect_callback();
  static void increment_query_count();

private:
  dbobject(const dbobject& orig);

  static bool connect_private(const char* host, const char* db, const char* user, const char* passwd);
  static int num_reconnects;
  static string dbhost, dbpass, dbuser, dbname;
  static void (*func)(int);
  static unsigned long query_count;

  friend ostream& operator<< (ostream& out, dbobject &x);

};

ostream& operator<< (ostream& out, dbobject &x);

} // namespace db

#endif
)DBOBJH";

//--------------------------------------------------------------------------------
// dbobject.cpp

const char *dbobject_c = R"DBOBJC(//
// This file generated by the C++ DB framework: https://github.com/aaronbloomfield/cpp-db-framework

#include <iostream>
#include <string>
#include <sstream>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

#include "dbobject.h"

using namespace std;

namespace db {

string dbobject::dbpass = string();
string dbobject::dbname = string();
string dbobject::dbuser = string();
string dbobject::dbhost = string();
void (*dbobject::func)(int) = NULL;
int dbobject::num_reconnects = 0;
bool dbobject::_verbose = false;
MYSQL* dbobject::theconn = NULL;
unsigned long dbobject::query_count = 0;

dbobject::dbobject() {
}

dbobject::dbobject(const dbobject& orig) {
}

dbobject::~dbobject() {
}

void dbobject::enable_reconnects (string host, string name, string user, string pass, int num) {
  dbpass = pass;
  dbhost = host;
  dbname = name;
  dbuser = user;
  num_reconnects = num;
}

bool dbobject::reconnect() {
  if ( num_reconnects == 0 ) {
    cerr << "No more reconnect attempts allowed." << endl;
    return false;
  }
  cerr << "Attempting to reconnect to the DB (" << num_reconnects-- << " more attempts allowed)..." << endl;
  if ( connect_private(dbhost.c_str(),dbname.c_str(),dbuser.c_str(),dbpass.c_str()) ) {
    cerr << "Reconnection attempt successful!" << endl;
    return true;
  } else {
    cerr << "Reconnection attempt failed!" << endl;
    return false;
  }
}

int dbobject::num_reconnects_allowed() {
  return num_reconnects;
}

void dbobject::set_reconnect_callback ( void (*f)(int) ) {
  func = f;
}

void dbobject::possibly_call_reconnect_callback() {
  if ( func != NULL )
    (*func)(num_reconnects);
}

unsigned long dbobject::get_query_count() {
  return query_count;
}

void dbobject::increment_query_count() {
  // all calls to this already are in a #pragma critical
  query_count++;
}

bool dbobject::connect_private(const char* host, const char* db, const char* user, const char* passwd) {
  MYSQL *conn = mysql_init(NULL);
  if (!mysql_real_connect(conn, host, user, passwd, db, 0, NULL, 0))
    return false;
  setMySQLConnection(conn);
  return true;
}

bool dbobject::connect(char* host, char* db, char* user, char* passwd) {
  bool ret;
#pragma omp critical(dbcpp)
  ret = connect_private(host, db, user, passwd);
  return ret;
}

bool dbobject::connect(string host, string db, string user, string passwd) {
  bool ret;
#pragma omp critical(dbcpp)
  ret = connect_private(host.c_str(),db.c_str(),user.c_str(),passwd.c_str());
  return ret;
}

void dbobject::disconnect() {
  if ( theconn != NULL )
    mysql_close(theconn);
  theconn = NULL;
}

void dbobject::setVerbose(bool which) {
  _verbose = which;
}

void dbobject::setMySQLConnection(MYSQL *conn) {
  theconn = conn;
}

MYSQL* dbobject::getMySQLConnection() {
  return theconn;
}

unsigned int dbobject::getLastInsertID(MYSQL *conn) {
  if ( conn == NULL )
    conn = theconn;
  string query = "select last_insert_id()";
  unsigned int id = 0, isbad;
  string error;
#pragma omp critical(dbcpp)
  {
    isbad = mysql_query(conn, query.c_str());
    increment_query_count();
    if ( !isbad ) {
      MYSQL_RES *res = mysql_use_result(conn);
      MYSQL_ROW row = mysql_fetch_row(res);
      sscanf (row[0], "%d", &id);
      mysql_free_result(res);
    } else
      error = string(mysql_error(conn));
  }
  if ( isbad ) {
#pragma omp critical(output)
    cerr << error << " in dbobject::getLastInsertID()" << endl;
    bool recret = false;
#pragma omp critical(dbcpp)
    recret = reconnect();
    if ( recret ) {
      possibly_call_reconnect_callback();
      cerr << "Calling method again..." << endl;
      return getLastInsertID(); // does NOT send in the 'conn' parameter
    } else {
      cerr << "Unable to reconnect to database." << endl;
      exit(1);
    }
  }
  return id;
}

void dbobject::executeUpdate(string query, MYSQL *conn) {
  if ( conn == NULL )
    conn = theconn;
  if ( conn == NULL ) {
    cerr << "Ack!  conn is null in dbobject::executeUpdate()" << endl;
    exit(1);
  }
  int isbad;
  string error;
#pragma omp critical(dbcpp)
  {
    isbad = mysql_query(conn, query.c_str());
    increment_query_count();
    if ( isbad )
      error = mysql_error(conn);
  }
  if ( isbad ) {
#pragma omp critical(output)
    cerr << error << " in dbobject::executeUpdate() on query: " << query << endl;
    bool recret = false;
#pragma omp critical(dbcpp)
    recret = reconnect();
    if ( recret ) {
      possibly_call_reconnect_callback();
      cerr << "Calling method again..." << endl;
      return executeUpdate(query); // does NOT send in the 'conn' parameter
    } else {
      cerr << "Unable to reconnect to database." << endl;
      exit(1);
    }
  }
}

void dbobject::raise_error(string s) {
  cout << s << endl;
  // change this to something else, if desired
  assert(0);
}

void dbobject::saveAll(vector<dbobject*> vec, MYSQL *conn) {
  if ( conn == NULL )
    conn = theconn;
  if ( conn == NULL ) {
    cerr << "Ack!  conn is null in dbobject::saveAll()" << endl;
    exit(1);
  }
  for ( unsigned int i = 0; i < vec.size(); i++ )
    vec[i]->save(); // already in its own critical section
}

ostream& operator<< (ostream& out, dbobject &x) {
  return x.put(out);
}

} // namespace db
)DBOBJC";

//--------------------------------------------------------------------------------
